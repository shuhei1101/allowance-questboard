# コーディング規約

## 目次
- [目次](#目次)
- [実装の手順](#実装の手順)
- [守るべき原則](#守るべき原則)
- [例外関連](#例外関連)
- [ビジネスロジック層](#ビジネスロジック層)
- [コメント関連](#コメント関連)
  - [関数とかクラスのドキュメンテーションの書き方](#関数とかクラスのドキュメンテーションの書き方)
- [関数](#関数)
  - [関数やメソッドのシグネチャの共有](#関数やメソッドのシグネチャの共有)
  - [引数や戻り値の型](#引数や戻り値の型)
- [Zodスキーマ関連](#zodスキーマ関連)

## 実装の手順
- `ユーザ`: 要件の定義
- `AI`: 要件に基づいた実装計画の作成
  - セクションの単位: レイヤーごと（例: ビジネスロジック層、データアクセス層、API層）
  - モジュール単位: 一ファイル単位
  - 含めること:
    - ファイルパス
    - 概要
- `ユーザ`: 実装計画のレビューと承認
- `AI`: 実装の実行

## 守るべき原則
- KISS: コードをシンプルにして、複雑なら分割すること
- DRY: 同じコードを繰り返さないこと
- YAGNI: 必要になるまで実装しないこと
- SRP: 一つのクラスや関数は一つの責務だけを持つこと(ビジネスロジックを除く)
- SLAP: メソッドを低レイヤー高レイヤーに分けること
  - 例: ビジネスロジック層とデータアクセス層を分けること

## 例外関連
- アプリ内の例外はすべて`AppError`もしくは`AppError`を継承したクラスでthrowすること

## ビジネスロジック層
- フォルダ名: `services`
- ファイル名: 動詞+名詞(例: `createFamilyInvite.ts`)
- クラス？関数？: 関数型で記載すること
- 

## コメント関連
### 関数とかクラスのドキュメンテーションの書き方
```ts
/** ここにタイトルを書く（複数行コメントの例）
 *
 * ここに説明を書く */
interface Props {
  /** 表示するアイコン一覧 */
  icons: Icons;
  /** 現在選択されているアイコン */
  selectedIcon?: Icon;
  /** アイコンが選択された時のコールバック */
  onIconSelect: (icon: Icon) => void;
  /** アイコン取得関数 */
  getIconByName: GetIconByName;
}

// 良くない例↓
/**
 * サンプルインターフェース(縦に長くなってしまうためNG)
 * 
 * 説明文
 */
interface SampleInterface {
  /** 
   * サンプルプロパティ(NGな書き方)
   */
  sampleProperty: string;

}


```

- 一行のdocsは改行せずに/** */で囲む
- 複数行の場合でも、最初と最後の/** */は改行しない
- コメントは**日本語**で記述すること
- ソースコード内のコメントに絵文字などは使わないこと
- 引数や戻り値は必ずコメントを記載すること
- 一行のコメントを書くときのルール
  - `〜する`や`〜です`などの言葉は省くこと
  - 一文の時は最後に丸`。`をつけないこと
  	- 例: 
  		- ✗: hogeを処理する。
  		- ○: hogeを処理

- 複数行コメントを書くときのルール
  - 極力スマートにシンプルに記述すること


## 関数
### 関数やメソッドのシグネチャの共有
- tsで関数やメソッドのシグネチャはtypeを用いて共有すること
```ts
// testFunction.ts
export type TestFunction = (params: { id: string, name: string }) => void;  // ファイルの一番上に共有するシグネチャを書くこと

export const testFunction: TestFunction = (params) => {  // 対象の関数はシグネチャを参照しておく
  // ...
};


// anotherFile.ts
import { TestFunction } from './testFunction';

const anotherFunction = (params: {
  testFunction: TestFunction;  // ここでシグネチャを共有することにより、テスタブルになる
}) => {
  // ...
}

```

### 引数や戻り値の型
- 引数は必ずparamsをつけること
```ts
test(params: { id: string, name: string }): void {
  // ...
}
```
- もしくは、型定義を使用すること
```ts
export interface TestParams {
  id: string;
  name: string;
};
test(params: TestParams): void {
  // ...
}
```
- 戻り値は必ず型を指定すること
```ts
export interface TestResult {
  success: boolean;
  message: string;
}
test(params: TestParams): TestResult {
  // ...
  return {
    success: true,
    message: '処理が成功しました',
  };
}
``` 

## Zodスキーマ関連
- Zodスキーマを定義するときは、極力値オブジェクト内のスキーマを使用すること
```ts
// 値オブエジェクト.ts
export const SampleObjectSchema = z.string();  // ファイルの一番上にZodスキーマを書くこと
// 値オブエジェクトはメンバが一つしかないため、z.objectにはしないこと

/** 招待コードを表す値オブジェクト */
export class SampleObject extends BaseValueObject<string, typeof SampleObjectSchema> {
  constructor(value: string) {
    super({ value });
  }
  ...
}

// xxxRouter.ts

// レスポンススキーマ
export const sampleResponseSchema = z.object({
  sampleObject: SampleObjectSchema  // 値オブジェクトのスキーマを使用すること
});

```
- 値オブエジェクトのスキーマでは、文字列制限などは書かない
  - 理由: 値オブジェクト自身が制約をもつため、値オブジェクトのスキーマで制約を書くと二重になるため

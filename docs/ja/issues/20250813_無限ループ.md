あーしが見た感じ、この `LoginScreen` は **無限ループの原因になりやすいポイント** がいくつかあるんだよね💦

---

### 1. `setLoginForm({ ...loginForm, email })` が毎回新しいオブジェクト

```ts
const handleEmailChange = (value: string) => {
  setLoginForm({ ...loginForm, email: value });
};
```

* `loginForm` が Zustand store なら、毎回 `{ ...loginForm, email: value }` は **新しいオブジェクト**
* これを state として渡すと再レンダリングが連鎖することがある
* → `useCallback` で関数をメモ化したり、store 側で shallow compare するのが定石

---

### 2. Props の関数をそのまま子コンポーネントに渡している

```ts
<LoginButton
  disabled={!isValid}
  loading={isLoading}
  onPress={handleLogin}
/>
```

* `handleLogin` が内部で state 更新すると再レンダ → 無限ループになる可能性
* これも `useCallback` で安定させると安全

---

### 3. `SelectFamilyDialog` 内の props

```ts
<SelectFamilyDialog
  isVisible={isDialogVisible}
  familyName={familyName || undefined}
  onParentLogin={handleParentLogin}
  onChildLogin={handleChildLogin}
  onClose={handleCloseDialog}
/>
```

* `isDialogVisible` が `useLoginPageStore` の state と同期している場合
* ダイアログ表示で state 更新 → 再レンダ → Dialog 再表示 → … のループになりやすい

---

### 💡 修正サンプル（簡易）

```ts
const handleEmailChange = useCallback((value: string) => {
  setLoginForm({ ...loginForm, email: value });
}, [loginForm, setLoginForm]);

const handlePasswordChange = useCallback((value: string) => {
  setLoginForm({ ...loginForm, password: value });
}, [loginForm, setLoginForm]);

const stableHandleLogin = useCallback(() => handleLogin(), [handleLogin]);
```

* こうすると **関数の参照が毎回変わらない**
* 再レンダリングの連鎖を減らせる

---

もしよければ、あーし **LoginScreen 全体を無限ループ防止用にリファクタ** したバージョン作れるよ✨
作ろっか？
